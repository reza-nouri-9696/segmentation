# -*- coding: utf-8 -*-
"""dataset_unet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R7e61t4qXJhzxXbjM0XTBoILLwGDq2LE
"""

import torch.nn as nn
import torch

class conv_block(nn.Module):
    def __init__(self, in_c, out_c):
        super().__init__()
        self.conv1 = nn.Conv2d(in_c, out_c, kernel_size=3, padding=1)
        self.bn1 = nn.BatchNorm2d(out_c)
        self.conv2 = nn.Conv2d(out_c, out_c, kernel_size=3, padding=1)
        self.bn2 = nn.BatchNorm2d(out_c)
        self.relu = nn.ReLU(inplace=True)

    def forward(self, x):
        x = self.conv1(x)
        x = self.bn1(x)
        x = self.relu(x)
        x = self.conv2(x)
        x = self.bn2(x)
        x = self.relu(x)
        return x

class DownBlock(nn.Module):
    def __init__(self, in_channels, out_channels, drop=0.3):
        super().__init__()
        self.double_conv = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, kernel_size=3, stride=1),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True),
            nn.Conv2d(out_channels, out_channels, 3, 2, 1),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True),
            nn.Dropout(p=drop)
        )

    def forward(self, x):
        return self.double_conv(x)

class UpBlock(nn.Module):
    def __init__(self, in_channels, out_channels, drop=0.3):
        super().__init__()
        self.up_conv = nn.Sequential(
            nn.ConvTranspose2d(in_channels, out_channels, kernel_size=2, stride=2),
            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(),
            nn.Dropout(p=drop)
        )

    def forward(self, x, shape):
        out = self.up_conv(x)
        if out.shape[2] != shape[2] or out.shape[3] != shape[3]:
            out = torch.nn.functional.interpolate(out, size=shape[2:], mode='bilinear', align_corners=True)
        return out

class VAEnet(nn.Module):
    def __init__(self, in_channels=3, out_channels=1, drop=0.4):
        super().__init__()
        # Downsampling
        self.down1 = DownBlock(in_channels, 64)
        self.down2 = DownBlock(64, 128)
        self.down3 = DownBlock(128, 256)
        self.down4 = DownBlock(256, 512)

        # Latent space
        self.mu = nn.Sequential(
            nn.Conv2d(512, 512, kernel_size=3, padding=1),
            nn.BatchNorm2d(512),
            nn.Sigmoid()
        )
        self.sigma = nn.Sequential(
            nn.Conv2d(512, 512, kernel_size=3, padding=1),
            nn.BatchNorm2d(512),
            nn.Sigmoid()
        )

        # Bottleneck
        self.bottle1 = nn.Conv2d(512, 1024, kernel_size=3, padding=1)
        self.norm1 = nn.BatchNorm2d(1024)
        self.relu = nn.ReLU()
        self.drop = nn.Dropout(p=drop)

        self.bottle2 = nn.Conv2d(1024, 512, kernel_size=3, padding=1)
        self.norm2 = nn.BatchNorm2d(512)

        self.bottle3 = nn.Conv2d(512, 1024, kernel_size=3, padding=1)
        self.norm3 = nn.BatchNorm2d(1024)

        # Upsampling
        self.up1 = UpBlock(1024, 512)
        self.up2 = UpBlock(512, 256)
        self.up3 = UpBlock(256, 128)
        self.up4 = UpBlock(128, 64)

        # Output
        self.out_conv = nn.Sequential(
            nn.Conv2d(64, out_channels, kernel_size=1),
            nn.Sigmoid()
        )

    def reparameterize(self, mu, sigma):
        std = torch.exp(0.5 * sigma)
        eps = torch.randn_like(std)
        z = mu + eps * std
        return z

    def forward(self, x):
        x1 = self.down1(x)
        x2 = self.down2(x1)
        x3 = self.down3(x2)
        x4 = self.down4(x3)

        # Get mean and variance
        mu = self.mu(x4)
        sigma = self.sigma(x4)
        x = self.reparameterize(mu, sigma)

        x = self.bottle1(x)
        x = self.norm1(x)
        x = self.relu(x)
        x = self.drop(x)

        x = self.bottle2(x)
        x = self.norm2(x)
        x = self.relu(x)
        x = self.drop(x)

        x = self.bottle3(x)
        x = self.norm3(x)
        x = self.relu(x)
        x = self.drop(x)

        x = self.up1(x, [1, 256, 31, 31])
        x = self.up2(x, [1, 128, 63, 63])
        x = self.up3(x, [1, 64, 127, 127])
        x = self.up4(x, [1, 3, 256, 256])

        out = self.out_conv(x)
        return out

# Example usage:
# model = VAEnet()